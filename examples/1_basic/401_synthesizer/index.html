<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="../../dist/xnew.js"></script>
  <script src="../../thirdparty/tailwindcss/playcdn.js"></script>
</head>

<body class="m-0 p-0 w-full h-screen overflow-hidden">
  <div id="main" class="relative w-full h-full"></div>
  <script>
    xnew(document.querySelector('#main'), (unit) => {
      xnew.nest('<div class="m-2">')
      xnew(Keyboard);
      xnew(CodeBlock);
      xnew('<div class="flex my-3">', () => {
        xnew(Oscillator);
        xnew(Filter);
        xnew(Amp);
        xnew(Options);
      });
    });
  
    function Keyboard() {
      xnew.nest('<div class="flex">');
      for (let i = 2; i < 6; i++) {
        xnew('<div class="flex relative select-none">', (unit) => {
          for (let key = 0; key < 12; key++) {
            xnew(Key, { key, number: i  });
          }
        });
      }
      function Key(unit, { key, number }) {
        const list = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', ];
        const offset = { C: 0, D: 1, E: 2, F: 3, G: 4, A: 5, B: 6 };
        const w = 24, h = 128;

        if (list[key].indexOf('#') < 0) {
          xnew.nest(`<div class="word-break-normal box-border cursor-pointer flex flex-col-reverse items-center" style="width: ${w}px; height: ${h}px; border: 1px solid #000000;">`);
          unit.element.textContent = list[key] + number;
        } else {
          xnew.nest(`<div class="absolute word-break-normal box-border cursor-pointer flex flex-col-reverse items-center" style="width: ${w * 6 / 8}px; height: ${h * 9 / 16}px; left: ${offset[list[key][0]] * w + w * 5 / 8}px; border: 1px solid #000000; background: #000000">`);
        }

        let press = null;
        let startTime = 0;
        unit.on('touchstart mousedown mouseover', ({ event }) => {
          if (event.buttons === 1 || event.type === 'touchstart') {
            startTime = Date.now();
            const [oscillator, filter, amp, options] = [xnew.find(Oscillator)[0], xnew.find(Filter)[0], xnew.find(Amp)[0], xnew.find(Options)[0]];
            const param = { oscillator: oscillator.value, ...filter.value, ...amp.value, ...options.value};
            xnew.emit('+code1', { text: ' ' });
            xnew.emit('+code2', { text: `const synth = xnew.audio.synthesizer({ ${oscillator.json}${filter.json}${amp.json}${options.json} });\nsynth.press('${list[key] + number}', duration);` });
            const synth = xnew.audio.synthesizer(param);
            press = synth.press(list[key] + number);
          }
        });
        unit.on('touchend mouseup mouseout', () => {
          if (press) {
            xnew.emit('+code1', { text: `const duration = ${Date.now() - startTime};` });
            press.release();
            press = null;
          }
        });
      }
    }

    function CodeBlock() {
      xnew.nest('<div class="w-[670px] p-1 border rounded-lg text-sm">');
      const code1 = xnew('<pre class="user-select-text whitespace-pre-wrap p-1 m-1">');
      const code2 = xnew('<pre class="user-select-text whitespace-pre-wrap p-1 m-1">');
      code1.on('+code1', ({ text }) => code1.element.textContent = text);
      code2.on('+code2', ({ text }) => code2.element.textContent = text);
    }
    
    function Oscillator(unit) {
      xnew.nest('<div class="w-40 p-1 border rounded-lg">');
      xnew('<p>', 'oscillator');
      const data = {};
      const waveform = xnew(Waveform, { value: 2 });
      const envelope = xnew(Envelope, { value: 0.0, min: -36.0, max: +36.0, step: 1, checkable: true });
      const lfo = xnew(LFO, { value: 4, min: 0, max: 36, step: 1 });

      return {
        get value() {
          return { type: waveform.value, ...envelope.value, ...lfo.value };
        },
        get json() {
          return `oscillator: { type: '${waveform.value}', ${envelope.json}${lfo.json}}, `;
        },
      }
    }

    function Filter(unit) {
      xnew.nest('<div class="w-40 p-1 border rounded-lg">');
      const params = { activate: false, type: 'lowpass', cutoff: 1000 };
      xnew.extend(xnew.basics.GUIPanel, { name: 'filter', params });

      unit.checkbox('activate');
      const type = xnew(Radio, { name: 'type', labels: ['lowpass', 'highpass', 'bandpass'] });
      unit.number('cutoff', { min: 100, max: 4000, step: 10 });

      return {
        get value() {
          return params.activate ? { filter: { type: type.value, cutoff: params.cutoff }} : {};
        },
        get json() {
          return params.activate ? `filter: { type: '${type.value}', cutoff: ${params.cutoff}}, ` : '';
        },
      }
    }

    function Amp(unit) {
      xnew.nest('<div class="w-40 p-1 border rounded-lg">');
      xnew('<p>', 'amp');

      const envelope = xnew(Envelope, { value: 0.1, min: 0.0, max: 1.0, step: 0.1 });

      return {
        get value() {
          return { amp: { ...envelope.value, }};
        },
        get json() {
          return `amp: { ${envelope.json}}, `;
        },
      }
    }

    function Options(unit) {
      xnew.nest('<div class="w-40 p-1 border rounded-lg">');
      xnew('<p>', 'options');

      const reverb = xnew((unit) => {
        const params = { time: 1000, mix: 0.5 };
        xnew.extend(xnew.basics.GUIPanel, { name: 'reverb', open: true, params });

        unit.checkbox('activate');
        unit.number('time', { min: 0.0, max: 2000, step: 100 });
        unit.number('mix', { min: 0.0, max: 1.0, step: 0.1 });
        return {
          get value() { return params.activate ? { reverb: { time: params.time, mix: params.mix }} : {}; },
          get json() { return params.activate ? `reverb: { time: ${params.time}, mix: ${params.mix}, }, ` : ''; }
        };
      });

      return {
        get value() {
          return { ...reverb.value, };
        },
        get json() {
          return (reverb.value) ? `${reverb.json}` : '';
        },
      }
    }

    function Waveform(unit, { value = 0 }) {
      xnew.extend(xnew.basics.GUIPanel, { name: 'type', open: true });
      xnew.nest('<div class="m-1 flex">');
      const name = 'waveform' + xnew.find(Waveform).length;
      const labels = ['sine', 'triangle', 'square', 'sawtooth'];
      labels.forEach((label, i) => {
        xnew(`<label class="inline-block">`, (unit) => {
          xnew.nest('<div class="flex flex-col items-center">');
          const input = xnew(`<input name="${name}" type="radio" value="${i}">`);
          const svg = xnew(`<svg class="block w-6 h-5 m-1" viewBox="0 0 20 20">`);
          let points = null;
          if (label === 'sine') {
            points = '0 10 2 3 5 0 8 3 10 10 12 17 15 20 18 17 20 10';
          } else if(label === 'triangle') {
            points = '0 10 5 0 10 10 15 20 20 10';
          } else if(label === 'square') {
            points = '0 10 0 0 10 0 10 20 20 20 20 10';
          } else if(label === 'sawtooth') {
            points = '0 20 0 0 20 20';
          }
          svg.element.innerHTML = `<polyline stroke="#000" fill="none" stroke-width="2" points="${points}" />`;
          input.on('change', () => {
            if (input.element.checked) value = i;
          });
          if (i === value) {
            input.element.checked = true;
          }
        });
      });
      return {
        get value() { return labels[value]; },
      }
    }
    function Envelope(unit, { value, min, max, step, checkable = false }) {
      const params = { activate: !checkable, amount: value, attack: 200, decay: 200, sustain: 0.2, release: 200 };
      xnew.extend(xnew.basics.GUIPanel, { name: 'envelope', open: true, params });

      if (checkable) unit.checkbox('activate');
      const svg = xnew('<svg class="w-28 h-14 bg-black m-auto" viewBox="0 0 300 150">');
      unit.number('amount', { min, max, step });
      unit.number('attack', { min: 0, max: 500, step: 20 });
      unit.number('decay', { min: 0, max: 500, step: 20 });
      unit.number('sustain', { min: 0.0, max: 1.0, step: 0.1 });
      unit.number('release', { min: 0, max: 500, step: 20 }); 

      unit.on('render', () => {
        const [A, D, S, R] = [params.attack, params.decay, params.sustain, params.release];
        const points = `0 150 ${0.1 * A} ${10} ${0.1 * (A + D)} ${150 - 140 * S} ${0.1 * (A + D + 500)} ${150 - 140 * S} ${0.1 * (A + D + 500 + R)} 150`;
        svg.element.innerHTML = `<polyline stroke="#2B2" stroke-width="4" points="${points}" />`;
      });
      return {
        get value() { return params.activate ? { envelope: { amount: params.amount, ADSR: [params.attack, params.decay, params.sustain, params.release] }} : {}; },
        get json() { return params.activate ? `envelope: { amount: ${params.amount}, ADSR: [${params.attack}, ${params.decay}, ${params.sustain}, ${params.release}], }, ` : ''; }
      };
    }

    function LFO(unit, { value, min, max, step }) {
      const params = { amount: value, rate: 8 };
      xnew.extend(xnew.basics.GUIPanel, { name: 'LFO', open: true, params });

      unit.checkbox('activate');
      const waveform = xnew(Waveform, { value: 2 });
      unit.number('amount', { min, max, step });
      unit.number('rate', { min: 2, max: 36, step: 1 });

      return {
        get value() {
          return params.activate ? { LFO: { type: waveform.value, amount: params.amount, rate: params.rate }} : {};
        },
        get json() { return params.activate ? `LFO: { type: '${waveform.value}', amount: ${params.amount}, rate: ${params.rate}, }, ` : ''; }
      };
    }

    function Radio(unit, { name, labels, value = 0 }) {
      xnew.nest('<div>');
      labels.forEach((label, i) => {
        xnew(`<label class="inline-block">`, () => {
          const input = xnew(`<input name="${name}" type="radio" value="${i}">`);
          xnew('<span>', label);
          input.on('change', () => {
            if (input.element.checked) value = i;
          });
          if (i === value) {
            input.element.checked = true;
          }
        });
      });
      return {
        get value() { return labels[value]; },
      }
    }

  </script>
</body>
</html>