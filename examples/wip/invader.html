<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="../thirdparty/three.min.js"></script>
  <script src="../dist/xnew.js"></script>

  <style>
    html {
      height: -webkit-fill-available;
    }

    body {
      min-height: 100vh;
      min-height: -webkit-fill-available;
      position: absolute;
      margin: 0;
      inset: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="main" style="width: 100%; height: 100%;"></div>
  <script>
    xnew('#main', (self) => {
      const screen = xnew(xnew.Screen, { width: 1200, height: 800 });
      xnew.context('screen', screen);;

      // setting for three.js
      const three = xnew(ThreeMain, screen.canvas);

      xnew(Controller, three);
    });

    function ThreeMain(self) {
      const screen = xnew.context('screen');
      const renderer = new THREE.WebGLRenderer({ canvas: screen.canvas });
     
      const camera = new THREE.PerspectiveCamera(45, screen.width / screen.height);
      camera.position.set(0, -5, +150);

      const scene = new THREE.Scene();
      xnew.extend(ThreeObject, scene);
    
      scene.background = new THREE.Color(0xFFFFFF);
      scene.rotation.x = -60 / 180 * Math.PI;

      xnew(ThreeContents);

      return {
        update() {
          renderer.render(scene, camera);
        },
      }
    }

    function ThreeObject(self, object) {
      const parent = xnew.context('ThreeObject');
      xnew.context('ThreeObject', object);

      parent?.add(object);
      return {
        finalize() {
          parent?.remove(object);
        },
      }
    }

    function Controller() {
      const dpad = xnew({ style: 'position: absolute; left: 10px; bottom: 20px; z-index: 10;' }, DPad);
      dpad.on('-down -move -up', (event) => {
        dpad.emit('+object.move', event);
      })
      const button = xnew({ style: 'position: absolute; right: 20px; bottom: 20px; z-index: 10;' }, CircleButton);
      button.on('-down', (event) => {
        button.emit('+object.action');
      })

      const xwin = xnew(window);
      const state = {};
      xwin.on('keydown keyup', (event) => {
        state[event.code] = event.type === 'keydown' ? 1 : 0;
        const x = - (state['ArrowLeft'] ? 1 : 0) + (state['ArrowRight'] ? 1 : 0);
        xwin.emit('#object.move', { vector: { x, y: 0 } });
      });
    }

    function ThreeContents() {
      xnew(DirectionaLight, 20, 50, 100);
      xnew(AmbientLight);

      xnew(Ground, 1000, 0x333333);
      xnew(Blocks);
      xnew(Player, [0, -65]);
    }

    function DirectionaLight(self, x, y, z) {
      const object = new THREE.DirectionalLight(0xFFFFFF, 0.40);
      object.position.set(x, y, z);
      const s = object.position.length();
      object.castShadow = true;
      object.shadow.mapSize.width = 2048;
      object.shadow.mapSize.height = 2048;
      object.shadow.camera.left = -s * 1.0;
      object.shadow.camera.right = +s * 1.0;
      object.shadow.camera.top = -s * 1.0;
      object.shadow.camera.bottom = +s * 1.0;
      object.shadow.camera.near = +s * 0.1;
      object.shadow.camera.far = +s * 10.0;
      object.shadow.camera.updateProjectionMatrix();

      xnew.extend(ThreeObject, object);
    }

    function AmbientLight(self) {
      const object = new THREE.AmbientLight(0xFFFFFF, 0.50);

      xnew.extend(ThreeObject, object);
    }

    function Ground(self, size, color) {
      const geometry = new THREE.PlaneGeometry(size, size, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color });
      const object = new THREE.Mesh(geometry, material);
      object.receiveShadow = true;

      xnew.extend(ThreeObject, object);
    }

    function Blocks(self) {
      xnew.extend(ThreeObject, new THREE.Group());

      xnew(Block, [-36, -50]);
      xnew(Block, [-12, -50]);
      xnew(Block, [+12, -50]);
      xnew(Block, [+36, -50]);
    }

    function Player(self, [x, y]) {
      const object = new THREE.Group();
      object.position.set(x, y, 0);

      xnew.extend(ThreeObject, object);

      const data = [
        [0, 0, 0, 1, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1],
      ];
      xnew(CubeArray, data, [3, 2], 4, 0xAAFFAA);

      let move = null;
      self.on('+object.move', ({ vector }) => {
        move = vector;
      });
      return {
        update() {
          if (move) {
            object.position.x += +move.x * 0.5;
          }
          object.position.x = Math.min(50, Math.max(-50, object.position.x));
        },
      };
    }

    function Block(self, [x, y]) {
      const object = new THREE.Group();
      xnew.extend(ThreeObject, object);
      object.position.set(x, y, 0);
      const data = [
        [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1],
      ];
      xnew(CubeArray, data, [5, 4], 6, 0xFFAAAA);
    }

    function CubeArray(self, data, offset, size, color) {
      const object = new THREE.Group();
      xnew.extend(ThreeObject, object);

      for (let y = 0; y < data.length; y++) {
        for (let x = 0; x < data[y].length; x++) {
          if (data[y][x]) {
            for (let s = 0; s < size; s++) {
              xnew(Cube, [x - offset[0], offset[1] - y, s], [1, 1, 1], color);
            }
          }
        }
      }
    }

    function Cube(self, [x, y, z], [sx, sy, sz], color) {
      const geometry = new THREE.BoxGeometry(sx, sy, sz);
      const material = new THREE.MeshLambertMaterial({ color, });
      const object = new THREE.Mesh(geometry, material);
      xnew.extend(ThreeObject, object);
      object.position.set(x, y, z);

      object.castShadow = true;
    }


    function DPad(self, { size = 130, fill = '#FFF', fillOpacity = 0.8, stroke = '#000', strokeOpacity = 0.8, strokeWidth = 2 } = {}) {
      xnew.nest({ style: `position: relative; width: ${size}px; height: ${size}px; cursor: pointer; overflow: hidden; user-select: none;`, });

      const fillStyle = `fill: ${fill}; fill-opacity: ${fillOpacity};`;
      const strokeStyle = `stroke: ${stroke}; stroke-opacity: ${strokeOpacity}; stroke-width: ${strokeWidth / (size / 100)}; stroke-linejoin: round;`;

      const polygons = [
        '<polygon points="50 50 35 35 35  5 37  3 63  3 65  5 65 35"></polygon>',
        '<polygon points="50 50 35 65 35 95 37 97 63 97 65 95 65 65"></polygon>',
        '<polygon points="50 50 35 35  5 35  3 37  3 63  5 65 35 65"></polygon>',
        '<polygon points="50 50 65 35 95 35 97 37 97 63 95 65 65 65"></polygon>'
      ];

      const targets = polygons.map((polygon) => {
        return xnew({
          tagName: 'svg',
          style: `position: absolute; width: 100%; height: 100%; user-select: none; ${fillStyle}"`,
          viewBox: '0 0 100 100'
        }, polygon);
      });

      xnew({ tagName: 'svg', style: `position: absolute; width: 100%; height: 100%; user-select: none; fill: none; ${strokeStyle}"`, viewBox: '0 0 100 100' }, `
        <polyline points="35 35 35  5 37  3 63  3 65  5 65 35"></polyline>
        <polyline points="35 65 35 95 37 97 63 97 65 95 65 65"></polyline>
        <polyline points="35 35  5 35  3 37  3 63  5 65 35 65"></polyline>
        <polyline points="65 35 95 35 97 37 97 63 95 65 65 65"></polyline>
        <polygon points="50 11 42 20 58 20"></polygon>
        <polygon points="50 89 42 80 58 80"></polygon>
        <polygon points="11 50 20 42 20 58"></polygon>
        <polygon points="89 50 80 42 80 58"></polygon>
      `);

      const drag = xnew(xnew.DragEvent);

      drag.on('-down -move', ({ type, position }) => {
        const x = position.x - size / 2;
        const y = position.y - size / 2;
        const a = (y !== 0 || x !== 0) ? Math.atan2(y, x) : 0;
        const d = Math.min(1.0, Math.sqrt(x * x + y * y) / (size / 4));

        const vector = { x: Math.cos(a) * d, y: Math.sin(a) * d };
        vector.x = Math.abs(vector.x) > 0.5 ? Math.sign(vector.x) : 0;
        vector.y = Math.abs(vector.y) > 0.5 ? Math.sign(vector.y) : 0;
        targets[0].element.style.filter = (vector.y < 0) ? 'brightness(90%)' : '';
        targets[1].element.style.filter = (vector.y > 0) ? 'brightness(90%)' : '';
        targets[2].element.style.filter = (vector.x < 0) ? 'brightness(90%)' : '';
        targets[3].element.style.filter = (vector.x > 0) ? 'brightness(90%)' : '';
        self.emit(type, { type, vector });
      });

      drag.on('-up -cancel', ({ type }) => {
        const vector = { x: 0, y: 0 };
        targets[0].element.style.filter = '';
        targets[1].element.style.filter = '';
        targets[2].element.style.filter = '';
        targets[3].element.style.filter = '';
        self.emit(type, { type, vector });
      });
    }

    function CircleButton(self, { size = 80, fill = '#FFF', fillOpacity = 0.8, stroke = '#000', strokeOpacity = 0.8, strokeWidth = 2 } = {}) {
      xnew.nest({ style: `position: relative; width: ${size}px; height: ${size}px; user-select: none;`, });
      const fillStyle = `fill: ${fill}; fill-opacity: ${fillOpacity};`;
      const strokeStyle = `stroke: ${stroke}; stroke-opacity: ${strokeOpacity}; stroke-width: ${strokeWidth / (size / 100)}; stroke-linejoin: round;`;

      const target = xnew({ tagName: 'svg', style: `width: 100%; height: 100%; cursor: pointer; user-select: none; ${fillStyle} ${strokeStyle}`, viewBox: '0 0 100 100' }, `
        <circle cx="50" cy="50" r="40"></circle>
      `);

      const drag = xnew(target, xnew.DragEvent);

      drag.on('-down', (event) => {
        target.element.style.filter = 'brightness(90%)';
        self.emit('-down', event);
      });
      drag.on('-up', (event) => {
        target.element.style.filter = '';
        self.emit('-up', event);
      });
    }
  </script>
</body>

</html>