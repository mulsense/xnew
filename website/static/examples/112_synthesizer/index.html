<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="../thirdparty/pixi.min.js"></script>
  <script src="../../dist/xnew.js"></script>
  <script src="../../dist/addons/xaudio.js"></script>
</head>

<body style="margin: 0; height: 100vh; margin: 8px;">
  <div id="main" style="width: 100%; height: 100%; margin: 8px;"></div>
  <script>
    xnew('#main', (self) => {
      xnew(Keyboard);
      xnew(CodeBlock);
      xnew({ style: { display: 'flex', margin: '12px 0' }}, () => {
        xnew(Oscillator);
        xnew(Filter);
        xnew(Amp);
        xnew(Options);
      });
    });
  
    function Keyboard() {
      xnew.nest({ style: { margin: '8px 0', display: 'flex' }});
      for (let i = 2; i < 6; i++) {
        xnew(Keyset, i);
      }
      function Keyset(self, number) {
        xnew.nest({ style: { display: 'flex', position: 'relative', userSelect: 'none' } });
        for (let i = 0; i < 12; i++) {
          xnew(Key, i, number);
        }
      }
      function Key(self, key, number) {
        const list = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', ];
        const offset = { C: 0, D: 1, E: 2, F: 3, G: 4, A: 5, B: 6 };
        const w = 24, h = 128;

        const style = { wordBreak: 'normal', boxSizing: 'border-box', cursor: 'pointer', display: 'flex', flexDirection: 'column-reverse', fontSize: '0.7em', alignItems: 'center' };
        if (list[key].indexOf('#') < 0) {
          Object.assign(style, { width: `${w}px`, height: `${h}px`, border: '1px solid #000000' });
          xnew.nest({ style });
          self.element.textContent = list[key] + number;
        } else {
          Object.assign(style, { width: `${w * 6 / 8}px`, height: `${h * 9 / 16}px`, background: '#000000', position: 'absolute', left: `${offset[list[key][0]] * w + w * 5 / 8}px` });
          xnew.nest({ style });
        }

        let press = null;
        let startTime = 0;
        self.on('touchstart mousedown mouseover', (event) => {
          if (event.buttons === 1 || event.type === 'touchstart') {
            startTime = Date.now();
            const [oscillator, filter, amp, options] = [xnew.find(Oscillator)[0], xnew.find(Filter)[0], xnew.find(Amp)[0], xnew.find(Options)[0]];
            const param = { oscillator: oscillator.value, ...filter.value, ...amp.value, };
            self.emit('+code1', ' ');
            self.emit('+code2', `const synth = xaudio.synthesizer({ ${oscillator.json}${filter.json}${amp.json}}${options.json});\nsynth.press('${list[key] + number}', duration);`);
            const synth = xaudio.synthesizer(param, options.value);
            press = synth.press(list[key] + number);
          }
        });
        self.on('touchend mouseup mouseout', () => {
          if (press) {
            self.emit('+code1',`const duration = ${Date.now() - startTime};`);
            press.release();
            press = null;
          }
        });
      }
    }

    function CodeBlock() {
      xnew.nest({ style: { width: '670px', padding: '4px', fontSize: '0.8em', border: '1px solid #AAA', borderRadius: '4px' } });
      const code1 = xnew({ tagName: 'pre', style: { maxWidth: '1200px', userSelect: 'text', whiteSpace: 'pre-wrap', padding: '1px', margin: '1px' }});
      const code2 = xnew({ tagName: 'pre', style: { maxWidth: '1200px', userSelect: 'text', whiteSpace: 'pre-wrap', padding: '1px', margin: '1px' }});
      code1.on('+code1', (text) => code1.element.textContent = text);
      code2.on('+code2', (text) => code2.element.textContent = text);
    }
    
    function Oscillator(self) {
      xnew.extend(Block, 'oscillator');

      const data = {};
      const waveform = xnew(Waveform, 2);
      const envelope = xnew(Envelope, { value: 0.0, min: -36.0, max: +36.0, step: 1}, true);
      const lfo = xnew(LFO, { value: 4, min: 0, max: 36, step: 1 });

      return {
        get value() {
          return { type: waveform.value, ...envelope.value, ...lfo.value };
        },
        get json() {
          return `oscillator: { type: '${waveform.value}', ${envelope.json}${lfo.json} }, `;
        },
      }
    }

    function Filter(self) {
      xnew.extend(Block, 'filter', true);

      const type = xnew(Radio, { name: 'type', labels: ['lowpass', 'highpass', 'bandpass'] });
      const cutoff = xnew(Slider, { name: 'cutoff', value: 1000, min: 100, max: 4000, step: 10 });
      const envelope = xnew(Envelope, { value: 0, min: -36, max: 36, step: 1 }, true);
      const lfo = xnew(LFO, { value: 4, min: 0, max: 36, step: 1 });

      return {
        get value() {
          return self.checked ? { filter: { type: type.value, cutoff: cutoff.value, ...envelope.value, ...lfo.value }} : {};
        },
        get json() {
          return self.checked ? `filter: { type: '${type.value}', cutoff: ${cutoff.value}, ${envelope.json}${lfo.json}}, ` : '';
        },
      }
    }

    function Amp(self) {
      xnew.extend(Block, 'amp');

      const envelope = xnew(Envelope, { value: 0.1, min: 0.0, max: 1.0, step: 0.1 });
      const lfo = xnew(LFO, { value: 0.1, min: 0.0, max: 1.0, step: 0.1 });

      return {
        get value() {
          return { amp: { ...envelope.value, ...lfo.value, }};
        },
        get json() {
          return `amp: { ${envelope.json}${lfo.json}}, `;
        },
      }
    }

    function Options(self) {
      xnew.extend(Block, 'effect');

      const reverb = xnew((self) => {
        xnew.extend(Section, 'reverb', true);

        const time = xnew(Slider, { name: 'time', value: 1000, min: 0.0, max: 2000, step: 100 });
        const mix = xnew(Slider, { name: 'mix', value: 0.5, min: 0.0, max: 1.0, step: 0.1 });
        return {
          get value() { return self.checked ? { reverb: { time: time.value, mix: mix.value }} : {}; },
          get json() { return self.checked ? `reverb: { time: ${time.value}, mix: ${mix.value}, }, ` : ''; }
        };
      });

      const delay = xnew((self) => {
        xnew.extend(Section, 'delay', true);

        const time = xnew(Slider, { name: 'time', value: 500, min: 0, max: 2000, step: 100 });
        const feedback = xnew(Slider, { name: 'feedback', value: 0.5, min: 0.0, max: 0.9, step: 0.1 });
        const mix = xnew(Slider, { name: 'mix', value: 0.5, min: 0.0, max: 1.0, step: 0.1 });

        return {
          get value() {
            return self.checked ? { delay: { time: time.value, feedback: feedback.value, mix: mix.value }} : {};
          },
          get json() {
            return self.checked ? `delay: { time: ${time.value}, feedback: ${feedback.value}, mix: ${mix.value}, }, ` : '';
          }
        };
      });
      return {
        get value() {
          return { ...reverb.value, ...delay.value, };
        },
        get json() {
          return (reverb.value || delay.value) ? `, { ${reverb.json}${delay.json}}` : '';
        },
      }
    }

    function Waveform(self, value = 0) {
      xnew({ tagName: 'p' }, 'type');
      const name = 'waveform' + xnew.find(Waveform).length;
      const labels = ['sine', 'triangle', 'square', 'sawtooth'];
      labels.forEach((label, i) => {
        xnew({ tagName: 'label', style: { display: 'inline-block' }}, (self) => {
          xnew.nest({ style: { display: 'flex', flexDirection: 'column', alignItems: 'center' } });
          const input = xnew({ tagName: 'input', name, type: 'radio', value: i });
          const svg = xnew({ tagName: 'svg', style: { display: 'block', width: '30px', height: '20px', margin: '6px' }, viewBox: '0 0 20 20' });
          let points = null;
          if (label === 'sine') {
            points = '0 10 2 3 5 0 8 3 10 10 12 17 15 20 18 17 20 10';
          } else if(label === 'triangle') {
            points = '0 10 5 0 10 10 15 20 20 10';
          } else if(label === 'square') {
            points = '0 10 0 0 10 0 10 20 20 20 20 10';
          } else if(label === 'sawtooth') {
            points = '0 20 0 0 20 20';
          }
          svg.element.innerHTML = `<polyline stroke="#000" fill="none" stroke-width="2" points="${points}" />`;
          input.on('change', () => {
            if (input.element.checked) value = i;
          });
          if (i === value) {
            input.element.checked = true;
          }
        });
      });
      return {
        get value() { return labels[value]; },
      }
    }
    function Envelope(self, { value, min, max, step }, checkable = false) {
      xnew.extend(Section, 'envelope', checkable);

      const svg = xnew({ tagName: 'svg', style: `width: 120px; height: 60px; margin: 8px; background: #000;`, viewBox: '0 0 300 150' });
      const amount = xnew(Slider, { name: 'amount', value, min, max, step });
      const attack = xnew(Slider, { name: 'attack', value: 200, min: 0, max: 500, step: 20 });
      const decay = xnew(Slider, { name: 'decay', value: 200, min: 0, max: 500, step: 20 });
      const sustain = xnew(Slider, { name: 'sustain', value: 0.2, min: 0.0, max: 1.0, step: 0.1 });
      const release = xnew(Slider, { name: 'release', value: 200, min: 0, max: 500, step: 20 });

      render();
      attack.input.on('change input', () => { render(); });
      decay.input.on('change input', () => { render(); });
      sustain.input.on('change input', () => { render(); });
      release.input.on('change input', () => { render(); });

      function render() {
        const [A, D, S, R] = [attack.value, decay.value, sustain.value, release.value];
        svg.element.innerHTML = `
            <polyline stroke="#2B2" stroke-width="4" points="0 150 ${0.1 * A} ${10} ${0.1 * (A + D)} ${150 - 140 * S} ${0.1 * (A + D + 500)} ${150 - 140 * S} ${0.1 * (A + D + 500 + R)} 150" />
        `;
      }
      return {
        get value() {
          return self.checked ? { envelope: { amount: amount.value, ADSR: [attack.value, decay.value, sustain.value, release.value] }} : {};
        },
        get json() { return self.checked ? `envelope: { amount: ${amount.value}, ADSR: [${attack.value}, ${decay.value}, ${sustain.value}, ${release.value}], }, ` : ''; }
      };
    }

    function LFO(self, { value, min, max, step }) {
      xnew.extend(Section, 'LFO', true);

      const waveform = xnew(Waveform, 2);
      const amount = xnew(Slider, { name: 'amount', value, min, max, step });
      const rate = xnew(Slider, { name: 'rate', value: 8, min: 2, max: 36, step: 1 });

      return {
        get value() {
          return self.checked ? { LFO: { type: waveform.value, amount: amount.value, rate: rate.value }} : {};
        },
        get json() { return self.checked ? `LFO: { type: '${waveform.value}', amount: ${amount.value}, rate: ${rate.value}, }, ` : ''; }
      };
    }

    function Slider(self, { name, value, max, min, step }) {
      xnew({ tagName: 'span' }, name);
      xnew.nest({ style: { display: 'flex', alignItems: 'center' }});
      const input = xnew({ tagName: 'input', type: 'range',  style: 'width: 120px;', min: `${min}`, max: `${max}`, step: `${step}`, value });
      const span = xnew({ tagName: 'span' }, `${value}`);
      input.on('change input', () => span.element.textContent = input.element.value);
      return {
        get value() { return Number(input.element.value); },
        get input() { return input; },
      }
    }

    function Radio(self, { name, labels, value = 0 }) {
      xnew({ tagName: 'span' }, name);
      xnew.nest({});
      labels.forEach((label, i) => {
        xnew({ tagName: 'label', style: { display: 'inline-block' } }, () => {
          const input = xnew({ tagName: 'input', name, type: 'radio', value: i });
          xnew({ tagName: 'span' }, label);
          input.on('change', () => {
            if (input.element.checked) value = i;
          });
          if (i === value) {
            input.element.checked = true;
          }
        });
      });
      return {
        get value() { return labels[value]; },
      }
    }

    function Block(self, name, checkable = false) {
      xnew.nest({ style: { width: '160px', padding: '4px', border: '1px solid #000000', borderRadius: '4px' } });
      xnew.extend(Check, name, checkable);
    }

    function Section(self, name, checkable = false) {
      xnew.extend(Check, name, checkable);
    }

    function Check(self, name, checkable = false) {
      const header = xnew({});
      xnew(header, { tagName: 'span', style: 'font-size: 1.2em;' }, name);

      xnew.nest({ style: checkable ? 'display: none;' : ''});
      let check = null;

      if (checkable) {
        check = xnew(header, { tagName: 'input', type: 'checkbox', checked: false });
        check.on('change', () => {
          self.element.style.display = check.element.checked ? 'block' : 'none';
        })
      }
      return {
        get checked() { return check ? check.element.checked : true; },
      }
    }
  </script>
</body>
</html>